const fs = require('fs');
const path = require('path');
const glob = require('glob');
const chalk = require('chalk');

function run(options) {
  const {
    path: targetPath,
    ext,
    mode,
    dryRun,
    loggerPattern,
    backup,
    report,
    diff,
    ignore = []
  } = options;

  const pattern = loggerPattern
    ? new RegExp(loggerPattern)
    : /(console\.log|logger\.debug|print)\(.*\);?/;

  const ignoreFilePath = path.resolve('.logcleanerignore');
  if (fs.existsSync(ignoreFilePath)) {
    try {
      const fileIgnoreList = fs
        .readFileSync(ignoreFilePath, 'utf8')
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0);
      ignore.push(...fileIgnoreList);
      console.log(chalk.gray(`ðŸ“‚ Ignoring folders from .logcleanerignore`));
    } catch (error) {
      console.error(chalk.red(`Failed to read ignore file: ${error.message}`));
    }
  }

  const reportLog = [];

  ext.forEach(fileExt => {
    const globPattern = `${targetPath}/**/*${fileExt}`;
    glob(globPattern, {}, (err, files) => {
      if (err) {
        console.error(chalk.red(err));
        return;
      }

      const filteredFiles = files.filter(file =>
        !ignore.some(ignored => file.includes(ignored))
      );

      if (filteredFiles.length === 0) {
        console.log(chalk.yellow(`No ${fileExt} files found in ${targetPath}`));
        return;
      }

      filteredFiles.forEach(file => {
        const original = fs.readFileSync(file, 'utf8');
        const lines = original.split('\n');
        let changed = false;

        const newLines = lines.map((line, index) => {
          if (pattern.test(line)) {
            changed = true;
            const commented = mode === 'comment' ? `// ${line}` : '';
            if (dryRun && diff) {
              console.log(chalk.gray(`[DIFF] ${file} @ line ${index + 1}`));
              console.log(chalk.redBright(`- ${line}`));
              if (mode === 'comment') {
                console.log(chalk.greenBright(`+ ${commented}`));
              }
              if (mode === 'delete') {
                console.log(chalk.greenBright(`+ (removed)`));
              }
            } else if (dryRun) {
              console.log(chalk.cyan(`[DRY-RUN] ${file}: ${line.trim()}`));
            }
            return commented;
          }
          return line;
        });

        if (changed && !dryRun) {
          if (backup) {
            fs.writeFileSync(`${file}.bak`, original);
          }
          fs.writeFileSync(file, newLines.join('\n'));
          console.log(chalk.green(`[CLEANED] ${file}`));

          if (report) {
            const cleanedCount = lines.filter(line => pattern.test(line)).length;
            reportLog.push(`${file} | ${cleanedCount} lines | Mode: ${mode}`);
          }
        }
      });

      if (report && reportLog.length > 0) {
        const reportContent = [
          `log-cleaner report - ${new Date().toLocaleString()}`,
          `Target: ${targetPath}`,
          `Mode: ${mode}`,
          `Extensions: ${ext.join(',')}`,
          '',
          ...reportLog
        ].join('\n');

        fs.writeFileSync('log-cleaner-report.txt', reportContent);
        console.log(chalk.magenta(`ðŸ“„ Report saved to log-cleaner-report.txt`));
      }
    });
  });
}

module.exports = { run };